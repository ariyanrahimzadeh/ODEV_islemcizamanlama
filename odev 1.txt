1111111
def CalculateWaitingTime(at, bt, N):

  
  wt = [0]*N;

  wt[0] = 0;

  print("P.No.\tArrival Time\t" , "Burst Time\tWaiting Time");
  print("1" , "\t\t" , at[0] , "\t\t" , bt[0] , "\t\t" , wt[0]);

  for i in range(1,5):
    wt[i] = (at[i - 1] + bt[i - 1] + wt[i - 1]) - at[i];

    print(i + 1 , "\t\t" , at[i] , "\t\t" , bt[i] , "\t\t" , wt[i]);
  
  average = 0.0;
  sum = 0;

  
  for i in range(5):
    sum = sum + wt[i];
  
  average = sum / 5;

  print("Average waiting time = " , average);


if name == 'main':
  
  N = 5;


  at = [ 0, 1, 2, 3, 4 ];

  bt = [ 4, 3, 1, 2, 5 ];

  CalculateWaitingTime(at, bt, N);


222222222222222222


process_data_raw = [
    [1, 1, 7],
    [2, 2, 5],
    [3, 3, 1],
    [4, 4, 2],
    [5, 5, 8]
]

processes = []
for p in process_data_raw:
    processes.append([p[0], p[1], p[2], p[2], 0, 0, 0, 0]) 

NUM_PROCESSES = len(processes)
current_time = 0
completed_count = 0
results_dict = {}
i = 0
p = None
min_index = -1
ready_queue = []
r = None

while completed_count < NUM_PROCESSES:
    
    ready_queue = []
    i = 0
    while i < NUM_PROCESSES:
        p = processes[i]
        if p[1] <= current_time and p[7] == 0:
            ready_queue.append((p[2], p[1], p[0], i)) 
        i += 1
        
    if ready_queue:
        ready_queue.sort() 
        
        min_index = ready_queue[0][3]
        current_process = processes[min_index]
        
        pid, at, bt = current_process[0], current_process[1], current_process[2]

        if current_time < at:
            current_time = at

        ct = current_time + bt
        
        current_time = ct
        
        tat = ct - at
        wt = tat - bt
        
        current_process[4] = ct
        current_process[5] = tat
        current_process[6] = wt
        current_process[7] = 1
        
        completed_count += 1
        
        results_dict[pid] = {'AT': at, 'BT': bt, 'CT': ct, 'TAT': tat, 'WT': wt}

    else:
        next_arrival = float('inf')
        i = 0
        while i < NUM_PROCESSES:
            p = processes[i]
            if p[7] == 0 and p[1] > current_time:
                if p[1] < next_arrival:
                    next_arrival = p[1]
            i += 1
        
        if next_arrival != float('inf'):
            current_time = next_arrival
        else:
            break

print("## Results of Non-Preemptive SJF Scheduling - Basic Code")
print("\nPID\tArrivalT\tBurstT\tCompletionT\tTAT\tWaitingT")

total_tat = 0
total_wt = 0
output_pids = sorted(results_dict.keys())

i = 0
while i < len(output_pids):
    pid = output_pids[i]
    r = results_dict[pid]
    
    print(f"{pid}\t\t{r['AT']}\t\t{r['BT']}\t\t{r['CT']}\t\t{r['TAT']}\t\t{r['WT']}")
    
    total_tat += r['TAT']
    total_wt += r['WT']
    i += 1

print("\n--- Summary ---")
if NUM_PROCESSES > 0:
    avg_tat = total_tat / NUM_PROCESSES
    avg_wt = total_wt / NUM_PROCESSES
    print("Average Turn Around Time: {:.2f}".format(avg_tat))
    print("Average Waiting Time: {:.2f}".format(avg_wt))

3333333333333333333333333333333333333

process_data_raw = [
    [1, 1, 7],
    [2, 2, 5],
    [3, 3, 1],
    [4, 4, 2],
    [5, 5, 8]
]

processes = []
for p in process_data_raw:
    processes.append([p[0], p[1], p[2], p[2], 0, 0, 0])

NUM_PROCESSES = len(processes)
current_time = 0
completed_count = 0
results_dict = {}
i = 0
p = None
min_index = -1
ready_queue = []
r = None

while completed_count < NUM_PROCESSES:
    
    ready_queue = []
    i = 0
    while i < NUM_PROCESSES:
        p = processes[i]
        if p[1] <= current_time and p[3] > 0:
            ready_queue.append((p[3], p[1], p[0], i))
        i += 1
        
    if ready_queue:
        ready_queue.sort() 
        
        min_index = ready_queue[0][3]
        current_process = processes[min_index]
        
        current_process[3] -= 1
        current_time += 1
        
        if current_process[3] == 0:
            completed_count += 1
            
            pid, at, bt = current_process[0], current_process[1], current_process[2]
            
            ct = current_time
            tat = ct - at
            wt = tat - bt
            
            current_process[4] = ct
            current_process[5] = tat
            current_process[6] = wt

            results_dict[pid] = {'AT': at, 'BT': bt, 'CT': ct, 'TAT': tat, 'WT': wt}

    else:
        next_arrival = float('inf')
        i = 0
        while i < NUM_PROCESSES:
            p = processes[i]
            if p[3] > 0 and p[1] > current_time:
                if p[1] < next_arrival:
                    next_arrival = p[1]
            i += 1
        
        if next_arrival != float('inf'):
            current_time = next_arrival
        else:
            break

print("\nPID\tArrivalT\tBurstT\tCompletionT\tTAT\tWaitingT")

total_tat = 0
total_wt = 0
output_pids = sorted(results_dict.keys())

i = 0
while i < len(output_pids):
    pid = output_pids[i]
    r = results_dict[pid]
    
    print(f"{pid}\t\t{r['AT']}\t\t{r['BT']}\t\t{r['CT']}\t\t{r['TAT']}\t\t{r['WT']}")
    
    total_tat += r['TAT']
    total_wt += r['WT']
    i += 1

print("\n--- Summary ---")
if NUM_PROCESSES > 0:
    avg_tat = total_tat / NUM_PROCESSES
    avg_wt = total_wt / NUM_PROCESSES
    print("Average Turn Around Time: {:.2f}".format(avg_tat))
    print("Average Waiting Time: {:.2f}".format(avg_wt))

44444444444444444444444444444

import collections

quant = 2

input_data = [
    (0, 10),
    (0, 5),
    (0, 8),
    (0, 3),
    (0, 4)
]
NOP = len(input_data)

processes = []
i = 0
while i < NOP:
    at, bt = input_data[i]
    processes.append([i + 1, at, bt, bt, 0, 0, 0, 0])
    i += 1

current_time = 0
completed_count = 0
ready_queue = []
results_dict = {}
total_wt = 0
total_tat = 0

processes.sort(key=lambda x: x[1])

while completed_count < NOP:
    
    i = 0
    while i < NOP:
        p = processes[i]
        if p[1] <= current_time and p[7] == 0 and p[3] > 0:
            ready_queue.append(i)
            p[7] = 1
        i += 1
    
    if ready_queue:
        process_index = ready_queue.pop(0) 
        p = processes[process_index]
        
        time_to_run = min(quant, p[3])

        current_time += time_to_run
        p[3] -= time_to_run
        
        i = 0
        while i < NOP:
            p_check = processes[i]
            if p_check[1] <= current_time and p_check[7] == 0 and p_check[3] > 0:
                ready_queue.append(i)
                p_check[7] = 1
            i += 1

        if p[3] == 0:
            completed_count += 1
            
            p[4] = current_time
            p[5] = p[4] - p[1]
            p[6] = p[5] - p[2]
            
            total_wt += p[6]
            total_tat += p[5]
            
            results_dict[p[0]] = {'AT': p[1], 'BT': p[2], 'CT': p[4], 'TAT': p[5], 'WT': p[6]}

        else:
            ready_queue.append(process_index)
            
    else:
        earliest_arrival = float('inf')
        i = 0
        while i < NOP:
            p_check = processes[i]
            if p_check[3] > 0 and p_check[1] > current_time:
                if p_check[1] < earliest_arrival:
                    earliest_arrival = p_check[1]
            i += 1
            
        if earliest_arrival != float('inf'):
            current_time = earliest_arrival
        else:
            break

print("Time Quantum:", quant)
print("\nPID\tArrivalT\tBurstT\tCompletionT\tTAT\tWaitingT")

output_pids = sorted(results_dict.keys())

i = 0
while i < len(output_pids):
    pid = output_pids[i]
    r = results_dict[pid]
    
    print(f"{pid}\t\t{r['AT']}\t\t{r['BT']}\t\t{r['CT']}\t\t{r['TAT']}\t\t{r['WT']}")
    i += 1

print("\n--- Summary ---")
if NOP > 0:
    avg_tat = total_tat / NOP
    avg_wt = total_wt / NOP
    print("Average Turn Around Time: {:.2f}".format(avg_tat))
    print("Average Waiting Time: {:.2f}".format(avg_wt))
    print("\n")

5555555555555555555555555555

import heapq


input_data = [
    [1, 0, 10, 3],
    [2, 2, 5, 1],
    [3, 3, 2, 4],
    [4, 5, 8, 2]
]
NOP = len(input_data)


processes = []
i = 0
while i < NOP:
    pid, at, bt, p = input_data[i]
    processes.append([pid, at, bt, p, bt, 0, 0, 0, 0])
    i += 1

current_time = 0
completed_count = 0
ready_queue = [] 
results_dict = {}
total_wt = 0
total_tat = 0
current_running_index = -1

processes.sort(key=lambda x: x[1])

while completed_count < NOP:
    
    i = 0
    while i < NOP:
        p = processes[i]
        if p[1] <= current_time and p[8] == 0 and p[4] > 0:
            
            heapq.heappush(ready_queue, (p[3], p[1], i)) 
            p[8] = 1 
        i += 1
    
    if current_running_index != -1 and processes[current_running_index][4] > 0:
        p = processes[current_running_index]
        heapq.heappush(ready_queue, (p[3], p[1], current_running_index))
        current_running_index = -1
        
    if ready_queue:
        priority, at, process_index = heapq.heappop(ready_queue)
        current_running_index = process_index
        p = processes[current_running_index]
        
        current_time += 1
        p[4] -= 1 
        p[8] = 1 
        
        if p[4] == 0:
            completed_count += 1
            
            p[5] = current_time
            p[6] = p[5] - p[1]
            p[7] = p[6] - p[2]
            
            total_wt += p[7]
            total_tat += p[6]
            
            results_dict[p[0]] = {'AT': p[1], 'BT': p[2], 'P': p[3], 'CT': p[5], 'TAT': p[6], 'WT': p[7]}
            current_running_index = -1
            
    else:
        earliest_arrival = float('inf')
        i = 0
        while i < NOP:
            p_check = processes[i]
            if p_check[4] > 0 and p_check[1] > current_time:
                if p_check[1] < earliest_arrival:
                    earliest_arrival = p_check[1]
            i += 1
            
        if earliest_arrival != float('inf'):
            current_time = earliest_arrival
        else:
            break

print("\nPID\tAT\tBT\tPriority\tCT\tTAT\tWT")

output_pids = sorted(results_dict.keys())
i = 0
while i < len(output_pids):
    pid = output_pids[i]
    r = results_dict[pid]
    
    print(f"{pid}\t{r['AT']}\t{r['BT']}\t{r['P']}\t\t{r['CT']}\t{r['TAT']}\t{r['WT']}")
    i += 1

print("\n--- Summary ---")
if NOP > 0:
    avg_tat = total_tat / NOP
    avg_wt = total_wt / NOP
    print("Average Turn Around Time: {:.2f}".format(avg_tat))
    print("Average Waiting Time: {:.2f}".format(avg_wt))
    
    print("\n")

6666666666666666666666666666666666666666666666

import heapq


input_data = [
    [1, 0, 10, 3],
    [2, 2, 5, 1],
    [3, 3, 2, 4],
    [4, 5, 8, 2]
]
NOP = len(input_data)


processes = []
i = 0
while i < NOP:
    pid, at, bt, p = input_data[i]
    processes.append([pid, at, bt, p, bt, 0, 0, 0, 0])
    i += 1

current_time = 0
completed_count = 0
ready_queue = [] 
results_dict = {}
total_wt = 0
total_tat = 0
current_running_index = -1

processes.sort(key=lambda x: x[1])

while completed_count < NOP:
    
    i = 0
    while i < NOP:
        p = processes[i]
        if p[1] <= current_time and p[8] == 0 and p[4] > 0:
            
            heapq.heappush(ready_queue, (p[3], p[1], i)) 
            p[8] = 1 
        i += 1
    
    if current_running_index != -1 and processes[current_running_index][4] > 0:
        p = processes[current_running_index]
        heapq.heappush(ready_queue, (p[3], p[1], current_running_index))
        current_running_index = -1
        
    if ready_queue:
        priority, at, process_index = heapq.heappop(ready_queue)
        current_running_index = process_index
        p = processes[current_running_index]
        
        current_time += 1
        p[4] -= 1 
        p[8] = 1 
        
        if p[4] == 0:
            completed_count += 1
            
            p[5] = current_time
            p[6] = p[5] - p[1]
            p[7] = p[6] - p[2]
            
            total_wt += p[7]
            total_tat += p[6]
            
            results_dict[p[0]] = {'AT': p[1], 'BT': p[2], 'P': p[3], 'CT': p[5], 'TAT': p[6], 'WT': p[7]}
            current_running_index = -1
            
    else:
        earliest_arrival = float('inf')
        i = 0
        while i < NOP:
            p_check = processes[i]
            if p_check[4] > 0 and p_check[1] > current_time:
                if p_check[1] < earliest_arrival:
                    earliest_arrival = p_check[1]
            i += 1
            
        if earliest_arrival != float('inf'):
            current_time = earliest_arrival
        else:
            break

print("\nPID\tAT\tBT\tPriority\tCT\tTAT\tWT")

output_pids = sorted(results_dict.keys())
i = 0
while i < len(output_pids):
    pid = output_pids[i]
    r = results_dict[pid]
    
    print(f"{pid}\t{r['AT']}\t{r['BT']}\t{r['P']}\t\t{r['CT']}\t{r['TAT']}\t{r['WT']}")
    i += 1

print("\n--- Summary ---")
if NOP > 0:
    avg_tat = total_tat / NOP
    avg_wt = total_wt / NOP
    print("Average Turn Around Time: {:.2f}".format(avg_tat))
    print("Average Waiting Time: {:.2f}".format(avg_wt))
    

    print("\n")
